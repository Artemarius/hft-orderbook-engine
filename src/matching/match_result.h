#pragma once

/// @file match_result.h
/// @brief MatchResult POD struct and SelfTradePreventionMode enum.
///
/// MatchResult holds up to MAX_TRADES_PER_MATCH trades on the stack —
/// no heap allocation, no callbacks, no virtual dispatch. Designed for
/// the hot path where every allocation matters.

#include <cstddef>
#include <cstdint>
#include <type_traits>

#include "core/trade.h"
#include "core/types.h"

namespace hft {

/// How the matching engine handles self-trades (same participant on both sides).
enum class SelfTradePreventionMode : uint8_t {
    None,           // No prevention — self-trades allowed
    CancelNewest,   // Cancel the aggressive (incoming) order
    CancelOldest,   // Cancel the resting (passive) order
    CancelBoth      // Cancel both aggressive and resting
};

/// Status of a submitted order after matching.
enum class MatchStatus : uint8_t {
    Filled,         // Fully filled — no remainder
    PartialFill,    // Partially filled — remainder rests or cancelled
    Resting,        // No match — order placed on book
    Cancelled,      // Remainder cancelled (IOC/Market with no liquidity)
    Rejected,       // Rejected (FOK with insufficient liquidity, invalid price)
    SelfTradePrevented  // Aggressive order cancelled by STP
};

/// Maximum trades generated by a single order submission.
static constexpr size_t MAX_TRADES_PER_MATCH = 64;

/// Result of submitting an order through the matching engine.
/// Fixed-size, stack-allocated, trivially copyable.
struct MatchResult {
    MatchStatus status;
    uint32_t trade_count;
    Quantity filled_quantity;
    Quantity remaining_quantity;
    Trade trades[MAX_TRADES_PER_MATCH];
};

static_assert(std::is_trivially_copyable_v<MatchResult>,
              "MatchResult must be trivially copyable for hot-path use");
static_assert(std::is_standard_layout_v<MatchResult>,
              "MatchResult must be standard layout");

}  // namespace hft
